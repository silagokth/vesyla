#ifndef _{{ kind | upper }}_PKG_H
#define _{{ kind | upper }}_PKG_H

#include "instruction.h"
#include <cstdint>
#include <functional>
#include <unordered_map>

{% set class_name = kind | capitalize %}
class {{ class_name }};

namespace {{ kind | upper}}_PKG {

// Supported opcodes from ISA
enum OpCode {
{% for instruction in isa.instructions %}
    {% set instr_name = instruction.name | upper %}
    {{ instr_name }} = {{ instruction.opcode }}{% if not loop.last %},{% endif %}
{% endfor %}
};

// ISA segment definitions
inline const std::unordered_map<OpCode, std::vector<SegmentRange>> &getIsaDefinitions() {
  static const std::unordered_map<OpCode, std::vector<SegmentRange>> segmentsDef = {
    {% for instruction in isa.instructions %}
    {OpCode::{{ instruction.name | upper }}, {
      {% if type == 'resource' %}
      {% set current_lsb = isa.format.instr_bitwidth - isa.format.instr_type_bitwidth - isa.format.instr_opcode_bitwidth - isa.format.instr_slot_bitwidth %}
      {% else %}
      {% set current_lsb = isa.format.instr_bitwidth - isa.format.instr_type_bitwidth - isa.format.instr_opcode_bitwidth %}
      {% endif %}
      {% for segment in instruction.segments %}
      {% set current_lsb = current_lsb - segment.bitwidth %}
      SegmentRange("{{ segment.name | lower }}", {{ segment.bitwidth }}, {{ current_lsb }}){% if not loop.last %},{% endif %}
      {% endfor %}
    }}{% if not loop.last %},{% endif %}
    {% endfor %}
  };
  return segmentsDef;
}

// ISA verbo mappings
{% for instruction in isa.instructions %}
{% for segment in instruction.segments %}
{% if segment.verbo_map %}
enum {{ instruction.name | upper }}_{{ segment.name | upper }} {
{% for map in segment.verbo_map %}
  {{ instruction.name | upper }}_{{ segment.name | upper }}_{{ map.val | replace(' ', '_') | replace('(', '') | replace(')', '') | upper }} = {{ map.key }}{% if not loop.last %},{% endif %}
{% endfor %}
};
{% endif %}
{% endfor %}
{% endfor %}

// Instruction formats
{% for instruction in isa.instructions %}
struct {{ instruction.name | upper }}Instruction {
  uint32_t slot, {% for segment in instruction.segments %}{{ segment.name | lower }}{% if not loop.last %}, {% endif %}{% endfor %};

  {{ instruction.name | upper }}Instruction(const Instruction &instr) {
    slot = instr.slot;
    {% for segment in instruction.segments %}
    {{ segment.name | lower }} = instr.get("{{ segment.name | lower }}").value;
    {% endfor %}
  }
};
{% endfor %}

std::unordered_map<uint32_t, std::function<void(uint32_t)>>
createInstructionHandlers({{ class_name }} *{{ kind | lower }}_obj);

} // namespace {{ kind | upper}}_PKG

#endif // _{{ kind | upper }}_PKG_H
