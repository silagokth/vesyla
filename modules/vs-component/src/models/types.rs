use crate::utils::{generate_rtl_for_component, get_path_from_library};

use std::{collections::BTreeMap, fs, path::Path};

use hashlink::LinkedHashMap as LHashMap;
use yaml_rust2::{Yaml, YamlEmitter, YamlLoader};

pub type ParameterList = BTreeMap<String, u64>;

#[derive(Debug)]
pub enum DRRAError {
    Io(std::io::Error),
    ResourceDeclaredAsController,
    ControllerDeclaredAsResource,
    ComponentWithoutNameOrKind,
    ComponentWithoutISA,
    UnknownComponentType,
    CellWithoutController,
    CellWithoutResources,
    ParameterNotFound(String),
    IncompatibleISAFormat,
    ISAKindMismatch,
}

impl std::fmt::Display for DRRAError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DRRAError::ResourceDeclaredAsController => write!(f, "Resource declared as controller"),
            DRRAError::ControllerDeclaredAsResource => write!(f, "Controller declared as resource"),
            DRRAError::ComponentWithoutNameOrKind => write!(f, "Component without name or kind"),
            DRRAError::ComponentWithoutISA => write!(f, "Component without ISA"),
            DRRAError::UnknownComponentType => write!(f, "Unknown component type"),
            DRRAError::Io(err) => write!(f, "IO error: {}", err),
            DRRAError::CellWithoutController => write!(f, "Cell without controller"),
            DRRAError::CellWithoutResources => write!(f, "Cell without resources"),
            DRRAError::ParameterNotFound(param) => {
                write!(f, "Parameter not found: {}", param)
            }
            DRRAError::IncompatibleISAFormat => {
                write!(f, "Incompatible ISA formats among components")
            }
            DRRAError::ISAKindMismatch => {
                write!(f, "ISA kind mismatch among components")
            }
        }
    }
}

impl std::convert::From<std::io::Error> for DRRAError {
    fn from(_error: std::io::Error) -> Self {
        DRRAError::Io(_error)
    }
}

pub trait RTLComponent {
    fn kind(&self) -> &str;
    fn name(&self) -> &str;
    fn generate_rtl(&self, output_folder: &Path) -> std::io::Result<()>
    where
        Self: serde::Serialize,
    {
        generate_rtl_for_component(self.kind(), self.name(), output_folder, &self)
    }
    fn generate_bender(&self, output_folder: &Path) -> Result<(), DRRAError> {
        self.generate_bender_default(output_folder, None, None)
    }
    fn generate_bender_default(
        &self,
        output_folder: &Path,
        fingerprint: Option<String>,
        dependencies: Option<LHashMap<Yaml, Yaml>>,
    ) -> Result<(), DRRAError> {
        let component_path =
            get_path_from_library(&self.kind().to_string(), None).map_err(DRRAError::Io)?;
        let bender_filepath = Path::new(&component_path).join("Bender.yml");
        if !bender_filepath.exists() {
            return Err(DRRAError::Io(std::io::Error::new(
                std::io::ErrorKind::NotFound,
                format!(
                    "Bender file not found for {} (looking for {:?})",
                    self.name(),
                    bender_filepath
                ),
            )));
        }

        let bender_file = &fs::read_to_string(&bender_filepath).map_err(DRRAError::Io)?;
        let mut bender_yaml = YamlLoader::load_from_str(bender_file).map_err(|arg| {
            DRRAError::Io(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("Failed to parse Bender file for {}: {}", self.name(), arg),
            ))
        })?;
        let bender_yaml = &mut bender_yaml[0];

        if let Some(fingerprint) = fingerprint {
            bender_yaml["package"]["name"] =
                Yaml::String(format!("{}_{}", self.name(), fingerprint));
        }

        if let Some(dependencies) = dependencies {
            bender_yaml["dependencies"] = Yaml::Hash(dependencies);
        }

        // Write the modified Bender YAML to the output folder
        let mut yaml_string = String::new();
        let mut emitter = YamlEmitter::new(&mut yaml_string);
        emitter.dump(bender_yaml).map_err(|arg| {
            DRRAError::Io(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("Failed to emit Bender YAML for {}: {}", self.name(), arg),
            ))
        })?;

        let output_bender_path = output_folder.join("Bender.yml");
        let comment =
            "# This file was automatically generated by Vesyla. DO NOT EDIT.\n\n".to_string();
        fs::write(output_bender_path, comment + &yaml_string).map_err(DRRAError::Io)?;

        Ok(())
    }
    fn generate_hash(&mut self) -> String;
    fn get_fingerprint(&mut self) -> String;
}
