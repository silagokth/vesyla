use log::{info, warn};
use std::fs;
use std::io::Error;
use std::path::Path;

fn register_drra_library() -> Result<(), Error> {
    // Get the VESYLA_SUITE_PATH_COMPONENTS environment variable
    let vesyla_suite_path_components = std::env::var("VESYLA_SUITE_PATH_COMPONENTS")
        .expect("VESYLA_SUITE_PATH_COMPONENTS environment variable is not set");

    // Check if the sst-register command is available
    let output = std::process::Command::new("sst-register")
        .arg("--help")
        .output();
    if output.is_err() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::NotFound,
            "sst-register command not found",
        ));
    }

    // Execute sst-register command
    let output = std::process::Command::new("sst-register")
        .arg("drra")
        .arg(format!("drra_LIBDIR={}", vesyla_suite_path_components))
        .output()
        .expect("Failed to execute sst-register command");

    if !output.status.success() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::Other,
            "sst-register command failed",
        ));
    }

    Ok(())
}

fn gen_sst_config(arch_file: &Path, output_dir: &Path) {
    let output_dir = std::path::Path::new(output_dir);
    if !output_dir.exists() {
        fs::create_dir_all(output_dir).expect("Failed to create output directory");
    }

    let json_str = std::fs::read_to_string(arch_file).expect("Failed to read file");
    let arch: serde_json::Value = serde_json::from_str(&json_str).expect("Failed to parse json");

    // Apply the template
    let template = include_str!("../sst/sst_sim_template.py.jinja");
    let mut context = minijinja::Environment::new();
    context.add_template("sst_sim_template", template).unwrap();
    let result = context
        .get_template("sst_sim_template")
        .unwrap()
        .render(&arch);
    let comment = "# This file was automatically generated by Vesyla. DO NOT EDIT.\n\n".to_string();
    let output = comment + &result.expect("Failed to render template");

    // Write the output to a file
    let output_file = output_dir.join("sst_sim_conf.py");
    fs::write(&output_file, output).expect("Failed to write output file");

    info!(
        "Generated SST configuration file: {:?}",
        output_file.to_str().unwrap()
    );
}

pub fn generate(arch_file: &Path, output_dir: &Path) {
    if register_drra_library().is_err() {
        // Copy $SST_CORE_HOME/etc/sst/sstsimulator.conf to $HOME/.sst/sstsimulator.conf
        let sst_core_home =
            std::env::var("SST_CORE_HOME").expect("SST_CORE_HOME environment variable is not set");
        let home_dir = std::env::var("HOME").expect("HOME environment variable is not set");
        let source = Path::new(&sst_core_home).join("etc/sst/sstsimulator.conf");
        let home_dir = Path::new(&home_dir);
        let dest_dir = home_dir.join(".sst");
        if !dest_dir.exists() {
            fs::create_dir_all(&dest_dir).expect("Failed to create .sst directory");
        }
        let dest = dest_dir.join("sstsimulator.conf");
        if !dest.exists() {
            fs::copy(&source, &dest).expect("Failed to copy sstsimulator.conf");
        }

        if register_drra_library().is_err() {
            warn!("Failed to register DRRA library with SST. Please ensure that the SST installation is correct and that the sst-register command is available in your PATH.");
        }
    }
    gen_sst_config(arch_file, output_dir);
}
